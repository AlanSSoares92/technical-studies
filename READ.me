# âœ¨ Conceitos Java â€” 

![Java](https://img.shields.io/badge/linguagem-Java-red) ![POO](https://img.shields.io/badge/POO-conceitos-blue) ![JPA](https://img.shields.io/badge/JPA--Hibernate-green) ![Spring Data](https://img.shields.io/badge/Spring%20Data-experience-orange)

Uma referÃªncia rÃ¡pida, visual e organizada dos principais conceitos de ProgramaÃ§Ã£o Orientada a Objetos em Java â€” ideal para estudo e revisÃ£o.

---

## ğŸ“š SumÃ¡rio
- [VisÃ£o Geral](#visÃ£o-geral)
- [Classes Abstratas](#classes-abstratas)
- [MÃ©todos Abstratos](#mÃ©todos-abstratos)
- [super()](#super)
- [Objetos](#objetos)
- [Desacoplamento](#desacoplamento)
- [HeranÃ§a / Polimorfismo / AbstraÃ§Ã£o](#heranÃ§a--polimorfismo--abstraÃ§Ã£o)
- [JPA / Hibernate (Mapeamento)](#jpa--hibernate-mapeamento)
- [ExperiÃªncia com Spring Data](#experiÃªncia-com-spring-data)
- [Design Patterns Essenciais](#design-patterns-essenciais)
- [Encapsulamento & Modificadores](#encapsulamento--modificadores)
- [Resumo RÃ¡pido](#resumo-rÃ¡pido)
- [ContribuiÃ§Ã£o & LicenÃ§a](#contribuiÃ§Ã£o--licenÃ§a)

---

## VisÃ£o Geral
POO organiza o software usando "objetos" â€” entidades que combinam estado (atributos) e comportamento (mÃ©todos). O resultado: cÃ³digo modular, mais legÃ­vel e fÃ¡cil de manter â€” como peÃ§as de um quebra-cabeÃ§a.

---

## Classes Abstratas
Uma classe abstrata Ã© um modelo parcial: serve para definir comportamento/contratos comuns, mas nÃ£o pode ser instanciada diretamente.

- Pode ter:
  - Construtores
  - MÃ©todos concretos
  - MÃ©todos abstratos
  - Atributos e visibilidade normal

Exemplo:
```java
public abstract class Animal {
    private String nome;
    public Animal(String nome) { this.nome = nome; }
    public String getNome() { return nome; }
    public abstract void emitirSom();
}
```

> Dica: Use classes abstratas quando existe um comportamento comum com implementaÃ§Ã£o parcial e vocÃª quer forÃ§ar subclasses a completar partes especÃ­ficas.

---

## MÃ©todos Abstratos
MÃ©todos abstratos declaram a assinatura sem implementar a lÃ³gica â€” a responsabilidade da implementaÃ§Ã£o Ã© da subclasse.

```java
public abstract class Veiculo {
    public abstract void acelerar();
}

public class Carro extends Veiculo {
    @Override
    public void acelerar() {
        System.out.println("Carro acelerando!");
    }
}
```

---

## super()
super() chama o construtor da superclasse. TambÃ©m permite acessar versÃµes da superclasse de mÃ©todos ou atributos quando hÃ¡ sobrescrita.

```java
public class Pai {
    public Pai(String nome) { ... }
}
public class Filho extends Pai {
    public Filho() { super("nome"); }
}
```

---

## Objetos
Um objeto Ã© uma instÃ¢ncia concreta de uma classe â€” reÃºne estado (atributos) e comportamento (mÃ©todos). Em Java, tudo gira em torno de instanciar classes para representar entidades do domÃ­nio.

---

## Desacoplamento
Desacoplar = reduzir dependÃªncias diretas entre classes. BenefÃ­cios:
- Manutenibilidade
- Testabilidade
- Reuso

Cuidado: desacoplar demais traz complexidade. Use padrÃµes como Dependency Injection, camadas (Controller / Service / Repository) e DTOs com equilÃ­brio.

---

## HeranÃ§a â€¢ Polimorfismo â€¢ AbstraÃ§Ã£o

- HeranÃ§a (extends): reuso de cÃ³digo entre classes relacionadas.
- Polimorfismo: um tipo (ex.: interface ou superclasse) pode ter vÃ¡rias implementaÃ§Ãµes concretas; o comportamento real depende da instÃ¢ncia.
- AbstraÃ§Ã£o: definir contratos (interfaces/abstratas) focando no "o que", nÃ£o no "como".

Exemplo simples de polimorfismo:
```java
public interface Pagamento { void pagar(); }
public class Cartao implements Pagamento { public void pagar(){ /*...*/ } }
public class Boleto implements Pagamento { public void pagar(){ /*...*/ } }

public void processar(Pagamento p) { p.pagar(); }
```

---

## JPA / Hibernate (Mapeamento)
JPA/Hibernate conecta objetos Java a tabelas relacionais com anotaÃ§Ãµes declarativas.

Entidade bÃ¡sica:
```java
@Entity
@Table(name = "clientes")
public class Cliente {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(nullable = false)
    private String nome;
}
```

Relacionamentos comuns:
- One-to-One: @OneToOne + @JoinColumn
- One-to-Many / Many-to-One: @OneToMany(mappedBy="...") + @ManyToOne
- Many-to-Many: @ManyToMany + @JoinTable

Controle de propriedade: mappedBy vs JoinColumn/JoinTable â€” gerenciam como o relacionamento Ã© representado no banco.

---

## ExperiÃªncia com Spring Data
Pergunta tÃ­pica: "Spring Data? O que vocÃª usou?"

Resposta resumida (exemplo prÃ¡tico):
- Usei Spring Data JPA: JpaRepository, Query Methods, e consultas custom (JPQL/Native) quando necessÃ¡rio.
- Projeto: serviÃ§o para atualizar rating histÃ³rico.
  - Dados recebidos do DMPS (plataforma FICO).
  - RepositÃ³rio persistia em Azure Cosmos DB (via driver/adapter adequado).
  - Desenvolvi queries customizadas para operaÃ§Ãµes especÃ­ficas â€” aprendizado na prÃ¡tica, soluÃ§Ã£o entregue com sucesso.

Dica: documente queries importantes e mantenha testes de integraÃ§Ã£o para garantir comportamento com o banco.

---

## Design Patterns Essenciais
- MVC â€” separaÃ§Ã£o de responsabilidades
- Repository â€” abstrai persistÃªncia
- Service Layer â€” lÃ³gica de negÃ³cio
- DTO â€” transporte de dados entre camadas
- Exception Handler â€” centraliza tratamento de erros
- Singleton â€” instÃ¢ncia Ãºnica (usar com cuidado; frameworks geralmente gerenciam singletons)
- Decorator / Adapter â€” estender comportamento ou adaptar interfaces

---

## Encapsulamento & Modificadores
Encapsulamento protege o estado do objeto e controla acesso via mÃ©todos.

Modificadores:
- private â†’ sÃ³ a prÃ³pria classe
- protected â†’ classe + subclasses + mesmo pacote
- public â†’ qualquer lugar
- package-private (default) â†’ mesmo pacote

Exemplo:
```java
public class Conta {
    private double saldo;
    public double getSaldo() { return saldo; }
    public void depositar(double valor) {
        if (valor > 0) saldo += valor;
    }
}
```

---

## Resumo RÃ¡pido
- Encapsulamento: protege dados e controla acesso.
- HeranÃ§a: reuso de cÃ³digo e especializaÃ§Ã£o.
- Polimorfismo: mesmo contrato, mÃºltiplas implementaÃ§Ãµes.
- AbstraÃ§Ã£o: definir contratos (interfaces/abstratas).

---

## âœï¸ ContribuiÃ§Ã£o
ContribuiÃ§Ãµes sÃ£o bem-vindas:
- Abra uma issue para mudanÃ§as e grandes melhorias.
- Fork â†’ branch com nome descritivo â†’ PR com descriÃ§Ã£o clara.
- Inclua testes quando possÃ­vel.

---

## ğŸ“œ LicenÃ§a
MIT Â©AlanSSoares92

---
